#!/usr/bin/env python3
"""
TAC Code Optimizer using Mistral LLM
Optimizes Three-Address Code (TAC) generated by the compiler
"""

import sys
import os
from mistralai import Mistral

def read_tac_file(filename):
    """Read TAC code from file"""
    try:
        with open(filename, 'r') as f:
            return f.read()
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        sys.exit(1)

def write_optimized_tac(filename, content):
    """Write optimized TAC code to file"""
    with open(filename, 'w') as f:
        f.write(content)

def optimize_tac_with_mistral(tac_code, api_key):
    """
    Use Mistral LLM to optimize TAC code
    """
    client = Mistral(api_key=api_key)
    
    prompt = f"""You are an expert compiler optimizer. Analyze the following Three-Address Code (TAC) and optimize it. You must preserve the original functionality while improving efficiency. Do not change variable names, labels, or the overall structure of the code.

Apply these optimization techniques:
1. **Dead Code Rule (Very Important)**:

- Understand the code flow to identify variables that are declared and assigned but never used later. Run a liveness analysis internally.
- The IF Statement should be optimised taking care of the condition that if the condition is always true or false, the corresponding block should be retained and the other block should be removed.
- If a variable is never used in any later computation, it is considered dead.
- You MUST remove:
    • its declaration line (e.g., "- INT b")
    • its assignment (e.g., "b = ...")
    • any temporaries that compute values used only for that variable.
    eg:
    Input TAC:
calculate:
@t0 = 10 INT
- INT a
a = @t0 INT
@t1 = 20 INT
- INT b
b = @t1 INT
@t2 = 30 INT
- INT c
c = @t2 INT
@t3 = 5 INT
@t4 = a + @t3 INT
- INT res
res = @t4 INT
return res
end:

    Expected optimized TAC:
calculate:
@t0 = 10 INT
- INT a
a = @t0 INT
@t3 = 5 INT
@t4 = a + @t3 INT
- INT res
res = @t4 INT
return res
end:
- This applies even if the dead code appears BEFORE a return statement.
- Remove all dead code variables and their assignments from the TAC.

2. **Constant Folding**: Evaluate constant expressions at compile time
3. **Constant Propagation**: Replace variables with known constant values
4. **Common Subexpression Elimination**: Identify and reuse repeated calculations
5. **Copy Propagation**: Replace copied variables with their source
6. **Algebraic Simplification**: Simplify expressions (e.g., x + 0 = x, x * 1 = x)
7. **Strength Reduction**: Replace expensive operations with cheaper ones
8. **Register Allocation Hints**: Reduce temporary variable usage where possible

**Important Rules:**
- Maintain the exact same functionality and semantics
- Preserve all labels (#L0, #L1, etc.) in their correct positions
- Keep function declarations and boundaries intact
- Preserve input/output operations exactly as they are
- Keep all variable declarations (lines starting with "-")
- **Return ONLY the optimized TAC code, no explanations or markdown formatting**

Here is the TAC code to optimize:

```
{tac_code}
```

Provide the optimized TAC code:"""

    try:
        # print("Calling Mistral API for optimization...")
        response = client.chat.complete(
            model="mistral-small-latest",
            messages=[
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            temperature=0.3,  # Lower temperature for more deterministic output
            max_tokens=8000
        )
        
        optimized_code = response.choices[0].message.content.strip()
        
        # Remove markdown code blocks if present
        if optimized_code.startswith("```"):
            lines = optimized_code.split('\n')
            # Remove first and last lines if they are code block markers
            if lines[0].startswith("```"):
                lines = lines[1:]
            if lines and lines[-1].startswith("```"):
                lines = lines[:-1]
            optimized_code = '\n'.join(lines)
        
        return optimized_code
    
    except Exception as e:
        print(f"Error calling Mistral API: {e}")
        print("Returning original TAC code without optimization")
        return tac_code

def main():
    """Main function"""
    if len(sys.argv) < 2:
        print("Usage: python3 optimize_tac.py <input_tac_file> [output_file]")
        print("Example: python3 optimize_tac.py tac.txt optimized_tac.txt")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else "optimized_tac.txt"
    
    # Get API key from environment variable
    api_key = "V7MF2BCc13Zhrc9PLbpI9xc4tt3eTT6q"
    if not api_key:
        print("Error: MISTRAL_API_KEY environment variable not set")
        print("Please set it with: export MISTRAL_API_KEY='your-api-key'")
        sys.exit(1)
    
    # Read original TAC
    print(f"Reading TAC from {input_file}...")
    tac_code = read_tac_file(input_file)
    
    if not tac_code.strip():
        print("Warning: TAC file is empty")
        sys.exit(0)
    
    print(f"Original TAC size: {len(tac_code)} characters")
    
    # Optimize using Mistral
    optimized_tac = optimize_tac_with_mistral(tac_code, api_key)
    
    print(f"Optimized TAC size: {len(optimized_tac)} characters")
    
    # Write optimized TAC
    write_optimized_tac(output_file, optimized_tac)
    print(f"\nOptimization complete! Optimized TAC written to {output_file}")
    
    # Show statistics
    original_lines = len(tac_code.split('\n'))
    optimized_lines = len(optimized_tac.split('\n'))
    print(f"\nStatistics:")
    print(f"  Original lines: {original_lines}")
    print(f"  Optimized lines: {optimized_lines}")
    print(f"  Reduction: {original_lines - optimized_lines} lines ({((original_lines - optimized_lines) / original_lines * 100):.1f}%)")

if __name__ == "__main__":
    main()
